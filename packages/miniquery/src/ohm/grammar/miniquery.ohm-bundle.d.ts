// AUTOGENERATED FILE
import { BaseActionDict, Grammar, IterationNode, Node, NonterminalNode, Semantics, TerminalNode } from 'ohm-js';

export interface MiniQueryActionDict<T> extends BaseActionDict<T> {
  Main?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Expr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LogicExpr_match?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  LogicExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  RelExpr_match?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  RelExpr_match_eq?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  RelExpr_has?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  RelExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  InExpr_match?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  InExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PredicateExpr_is?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  PredicateExpr_like?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode,
    arg2: NonterminalNode,
  ) => T;
  PredicateExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  BetweenExpr_match?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode,
    arg2: NonterminalNode,
    arg3: TerminalNode,
    arg4: NonterminalNode,
  ) => T;
  BetweenExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  CallExpr_match?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode,
    arg3: TerminalNode,
  ) => T;
  CallExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PriExpr_paren?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  PriExpr_not?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  PriExpr_pos?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PriExpr_neg?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PriExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Array?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Value?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ListOf?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  TrailNonEmptyListOf?: (
    this: NonterminalNode,
    arg0: Node,
    arg1: IterationNode,
    arg2: IterationNode,
    arg3: IterationNode,
  ) => T;
  in?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  is?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  logic?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  like?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  between?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  ref?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  ident?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  literal?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  null?: (this: NonterminalNode, arg0: TerminalNode) => T;
  bool?: (this: NonterminalNode, arg0: TerminalNode) => T;
  string?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  int?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  uint?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  int_non_zero?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  float?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode) => T;
}

export interface MiniQuerySemantics extends Semantics {
  addOperation<T>(name: string, actionDict: MiniQueryActionDict<T>): this;

  extendOperation<T>(name: string, actionDict: MiniQueryActionDict<T>): this;

  addAttribute<T>(name: string, actionDict: MiniQueryActionDict<T>): this;

  extendAttribute<T>(name: string, actionDict: MiniQueryActionDict<T>): this;
}

export interface MiniQueryGrammar extends Grammar {
  createSemantics(): MiniQuerySemantics;

  extendSemantics(superSemantics: MiniQuerySemantics): MiniQuerySemantics;
}

declare const grammar: MiniQueryGrammar;
export default grammar;

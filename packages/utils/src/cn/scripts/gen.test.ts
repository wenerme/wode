import { test } from 'vitest';
import { getGenerateContext } from '../../scripts/getGenerateContext';

function parseCsv(v: string) {
  return v
    .split('\n')
    .filter(Boolean)
    .map((v) => v.split(',').slice(0, 2))
    .slice(1); // remove header
}

test(
  'division-gen',
  {
    timeout: 1000 * 60 * 30,
  },
  async () => {
    await generate();
  },
);

async function generate() {
  const { cache, writeData, writeSrc } = await getGenerateContext('cn/division');

  const stats: Record<string, any> = {};
  const entries: Record<string, [number, string][]> = {};
  const set = new Map<number, [number, string, number[]?]>();
  for (const fn of ['provinces', 'cities', 'areas', 'streets', 'villages']) {
    const rows: string[][] = await cache(
      `https://raw.githubusercontent.com/modood/Administrative-divisions-of-China/master/dist/${fn}.csv`,
    ).then(parseCsv);
    entries[fn] = rows.map(([k, v]) => {
      if (!v) {
        throw new Error(`empty value for ${k}`);
      }
      // csv name has quote
      return [parseInt(k), v.replace(/"/g, '')];
    });
    stats[
      {
        areas: 'counties',
        streets: 'towns',
      }[fn] || fn
    ] = rows.length;
  }

  const all = Object.values(entries).flat();
  for (const [k, v] of all) {
    const p = parent(k);
    set.set(k, [k, v]);
    if (p) {
      const par = set.get(parseInt(p));
      if (!par) {
        throw new Error(`missing parent ${p} for ${k}`);
      }
      par[2] ||= [];
      par[2].push(k);
    }
  }

  const full = Array.from(set.values());
  const dataset = {
    'village.json': full,
    'village.csv': full.map(([code, name]) => `${code},${name}`).join('\n'),
    'county.json': full
      .filter((v) => {
        return v[0] < 1000000;
      })
      .map((e) => {
        const [code, name] = e;
        // remove leaf children
        if (code > 10000) {
          return [code, name];
        }
        return e;
      }),
  };
  const srcs: Record<string, string> = {
    // preload small dataset
    //     'dataset.gen.ts': `// This if is generated by generate.ts, DO NOT EDIT
    // export const ProvinceCodes = [${entries.provinces.map(([k]) => JSON.stringify(String(k))).join(',')}];
    // `,
  };
  for (const [name, data] of Object.entries(dataset)) {
    await writeData(name, typeof data === 'object' ? JSON.stringify(data) : data);
  }
  for (const [name, data] of Object.entries(srcs)) {
    await writeSrc(name, typeof data === 'object' ? JSON.stringify(data) : data);
  }
  await writeData(`stats.json`, JSON.stringify(stats, null, 2));
}

type TreeNode = [number, TreeNode[]?];

export function search(arr: TreeNode[], val: number): [boolean, number] {
  let start = 0;
  let end = arr.length - 1;
  let mid;
  while (start <= end) {
    mid = Math.floor((start + end) / 2);
    if (arr[mid][0] === val) {
      return [true, mid];
    }

    if (val < arr[mid][0]) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return [false, mid ?? 0];
}

function parent(code: string | number) {
  return split(code).slice(0, -1).join('') || undefined;
}

function split(code: string | number) {
  if (!code) return [];
  code = String(code);
  return [
    //
    code.slice(0, 2),
    code.slice(2, 4),
    code.slice(4, 6),
    code.slice(6, 9),
    code.slice(9),
  ].filter((v) => parseInt(v));
}
